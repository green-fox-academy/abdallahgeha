# Final exam requirement

## Endpoint

[] Able to explain HTTP request communication flow
[] Able to demonstrate how to create an HTTP request
[] Able to recognize a REST endpoint (stateless/resource)
[] Able to send or receive data either in body or in URL params
[] Able to identify the different parts of a URL
[] Able to describe the most common HTTP response status codes

## Authentication

[] Able to explain the aim of authentication and authorization
[] Able to explain a token based authentication flow
[] Able to explain the differences of token and session based authentication

## Data flow

[] Able to identify separate responsibilities of the application
[] Able to demonstrate the flow of data through a feature of the project
[] Able to explain the difference between server-side and client-side rendering
[] Able to explain what dependency injection is and what problem it solves

## Testing

[] Able to explain the reason for testing
[] Able to explain the difference between unit and integration tests
[] Able to explain the advantages and disadvantages of unit and integration tests
[] Able to write simple unit test cases
[] Able to write simple project specific test cases
[] Able to explain the need for mocking

## DB

[] Able to explain how data is modeled in a database
[] Able to retrieve data from multiple tables using SQL
[] Able to use most common SQL aggregate functions
[] Able to perform simple CRUD operations using a tool (workbench/command line/...)
[] Able to explain how models are related in a database

## Refactor

[] Able to refactor the algorithmic exercise if necessary
[] Able to explain the goal of refactoring
[] Able to list the most common code smells
[] Able to explain the need for style guides and linters
[] Able to explain how to reduce the complexity of a method

## OOP

[] Able to explain difference between a class and an instance and the role of constructors
[] Able to explain where to use inheritance
[] Able to demonstrate good example of encapsulation
[] Able to explain the reason of using interfaces and abstract classes and the
  differences between them

## Development operations

[] Able to recognize and resolve merge conflicts
[] Able to explain workflow details on collaborating with version control
[] Able to explain the flow of releasing code to production servers
[] Able to show how the application is configured for different environments
[] Able to build the app from the command line interface

## Error Handling

[] Able to identify the relevant parts of a stack trace
[] Able to explain the difference between runtime and compile time errors
[] Able to show how errors are handled in the application
[] Able to explain where and why to use data/input validation
[] Able to demonstrate the debugging process
